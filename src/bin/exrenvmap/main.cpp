//
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) Contributors to the OpenEXR Project.
//

//-----------------------------------------------------------------------------
//
//      exrenvmap -- makes OpenEXR environment maps
//
//-----------------------------------------------------------------------------

#include <EnvmapImage.h>
#include <ImfEnvmap.h>
#include <ImfHeader.h>
#include <ImfMisc.h>
#include <OpenEXRConfig.h>
#include <ImfChannelList.h>
#include <ImfRgbaFile.h>
#include <ImfTiledRgbaFile.h>
#include <ImfStandardAttributes.h>
#include <ImfOutputFile.h>
#include <ImfTiledOutputFile.h>

#include <blurImage.h>
#include <makeCubeMap.h>
#include <makeLatLongMap.h>

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <cmath>

#include "namespaceAlias.h"
using namespace IMF;
using namespace std;

namespace
{

void
usageMessage (ostream& stream, const char* program_name, bool verbose = false)
{
    stream << "Usage: " << program_name << " [options] infile outfile" << endl;

    if (verbose)
    {
        std::string compressionNames;
        getCompressionNamesString ("/", compressionNames);

        stream
            << "\n"
               "Convert an OpenEXR latitude-longitude environment map\n"
               "into a cube-face environment map or vice versa.\n"
               "Reads an environment map image from infile, converts\n"
               "it, and stores the result in outfile.\n"
               "\n"
               "If the input file name contains a '%' character, then an\n"
               "input cube-face environment map is assembled from six\n"
               "square sub-images that represent the six faces of the cube.\n"
               "The names of the six image files are generated by replacing\n"
               "the % with +X, -X, +Y, -Y, +Z and -Z respectively.\n"
               "\n"
               "If the output file name contains a '%' character and\n"
               "the program has been instructed to produce a cube-face\n"
               "environment map, then the output image is split into six\n"
               "square sub-images that are saved in six separate output\n"
               "files.  The names of the files are generated by replacing\n"
               "the % with +X, -X, +Y, -Y, +Z and -Z respectively.\n"
               "\n"
               "Options:\n"
               "\n"
               "  -o            produces a ONE_LEVEL output file (default)\n"
               "\n"
               "  -m            produces a MIPMAP_LEVELS output file (-m has\n"
               "                no effect if the output image is split into\n"
               "                multiple files)\n"
               "\n"
               "  -c            the output file will be a cube-face environment\n"
               "                map (default)\n"
               "\n"
               "  -l            the output file will be a latitude-longitude\n"
               "                environment map\n"
               "\n"
               "  -ci           the input file is interpreted as a cube-face\n"
               "                environment map, regardless of its envmap\n"
               "                attribute\n"
               "\n"
               "  -li           the input file is interpreted as a latitude-\n"
               "                longitude environment map, regardless of its\n"
               "                envmap attribute (-li has no effect if the\n"
               "                input image is assembled from multiple files)\n"
               "\n"
               "  -f32, --float output pixels will be 32-bit floating-point\n"
               "                values (default is 16-bit half float)\n"
               "\n"
               "  -w x          sets the width of the output image to x pixels\n"
               "                (default is 256).  The height of the output image\n"
               "                will be x*6 pixels for a cube-face map, or x/2\n"
               "                pixels for a latitude-longitude map.\n"
               "\n"
               "  -f r n        sets the antialiasing filter radius to r\n"
               "                (default is 1.0) and the sampling rate to\n"
               "                n by n (default is 5 by 5).  Increasing r\n"
               "                makes the output image blurrier; decreasing r\n"
               "                makes the image sharper but may cause aliasing.\n"
               "                Increasing n improves antialiasing, but\n"
               "                generating the output image takes longer.\n"
               "\n"
               "  -b            blurs the environment map image by applying a\n"
               "                180-degree-wide filter kernel such that point-\n"
               "                sampling the blurred image at a location that\n"
               "                corresponds to 3D direction N returns the color\n"
               "                that a white diffuse reflector with surface\n"
               "                normal N would have if it was illuminated using\n"
               "                the original non-blurred image.\n"
               "                Generating the blurred image can be fairly slow.\n"
               "\n"
               "  -t x y        sets the output file's tile size to x by y pixels\n"
               "                (default is 64 by 64)\n"
               "\n"
               "  -p t b        if the input image is a latitude-longitude map,\n"
               "                pad the image at the top and bottom with t*h\n"
               "                and b*h extra scan lines, where h is the height\n"
               "                of the input image.  This is useful for images\n"
               "                from 360-degree panoramic scans that cover\n"
               "                less than 180 degrees vertically.\n"
               "\n"
               "  -d            sets level size rounding to ROUND_DOWN (default)\n"
               "\n"
               "  -u            sets level size rounding to ROUND_UP\n"
               "\n"
               "  -z x          sets the data compression method to x\n"
               "                ("
            << compressionNames.c_str ()
            << ",\n"
               "                default is zip)\n"
               "\n"
               "  -v            verbose mode\n"
               "\n"
               "  -h, --help    print this message\n"
               "\n"
               "      --version print version information\n"
               "\n"
               "Report bugs via https://github.com/AcademySoftwareFoundation/openexr/issues or email security@openexr.com\n"
               "";
    }
}

Compression
getCompression (const string& str)
{
    Compression c;
    getCompressionIdFromName (str, c);
    if (c == Compression::NUM_COMPRESSION_METHODS)
    {
        std::stringstream e;
        e << "Unknown compression method \"" << str << "\"";
        throw invalid_argument (e.str ().c_str ());
    }

    return c;
}

} // namespace

// Add forward declarations for the missing functions
void blurCubeMap(EnvmapImage& image, bool verbose);
void blurLatLongMap(EnvmapImage& image, bool verbose);
void resampleImage(const EnvmapImage& in, EnvmapImage& out, int level);

// Helper function to handle extreme values when converting to float
float convertRgbaValueToFloat(float value, float* maxValueFound, int* extremeValueCount) {
    // Check for NaN/Infinity
    if (value != value || !std::isfinite(value)) {
        (*extremeValueCount)++;
        return 0.0f;
    }
    
    // Keep track of maximum value for reporting
    if (value > *maxValueFound) {
        *maxValueFound = value;
    }
    
    // Check for extreme values
    const float safeMaxValue = 1.0e30f;
    if (value > safeMaxValue) {
        (*extremeValueCount)++;
        return safeMaxValue;
    }
    
    if (value < -safeMaxValue) {
        (*extremeValueCount)++;
        return -safeMaxValue;
    }
    
    return value;
}

// Function to report extreme values if found
void reportExtremeValues(int extremeValueCount, float maxValueFound, bool verbose) {
    if (extremeValueCount > 0 && verbose) {
        std::cout << "Warning: " << extremeValueCount 
                  << " extreme values found during final output. "
                  << "Maximum value: " << maxValueFound << std::endl;
        std::cout << "Some artifacts may still be visible in very bright areas." << std::endl;
    }
}

// The implementations should be before the main function

void
blurCubeMap(EnvmapImage& image, bool verbose)
{
    if (verbose)
        cout << "blurring cube-face map" << endl;
    
    blurImage(image, verbose);
}

void
blurLatLongMap(EnvmapImage& image, bool verbose)
{
    if (verbose)
        cout << "blurring latitude-longitude map" << endl;
    
    blurImage(image, verbose);
}

void
resampleImage(const EnvmapImage& in, EnvmapImage& out, int level)
{
    // Simple implementation to resample the environment map for mipmapping
    const IMATH::Box2i& inDw = in.dataWindow();
    const IMATH::Box2i& outDw = out.dataWindow();
    
    int inW = inDw.max.x - inDw.min.x + 1;
    int inH = inDw.max.y - inDw.min.y + 1;
    int outW = outDw.max.x - outDw.min.x + 1;
    int outH = outDw.max.y - outDw.min.y + 1;
    
    const IMF::Array2D<IMF::Rgba>& inPixels = in.pixels();
    IMF::Array2D<IMF::Rgba>& outPixels = out.pixels();
    
    // Scale factors for x and y
    float xScale = float(inW) / float(outW);
    float yScale = float(inH) / float(outH);
    
    for (int y = 0; y < outH; ++y)
    {
        for (int x = 0; x < outW; ++x)
        {
            // Calculate source pixel position
            float srcX = (x + 0.5f) * xScale - 0.5f;
            float srcY = (y + 0.5f) * yScale - 0.5f;
            
            // Simple bilinear interpolation
            int x0 = floor(srcX);
            int y0 = floor(srcY);
            int x1 = x0 + 1;
            int y1 = y0 + 1;
            
            float wx = srcX - x0;
            float wy = srcY - y0;
            
            // Clamp to edges
            x0 = std::max(0, std::min(x0, inW - 1));
            y0 = std::max(0, std::min(y0, inH - 1));
            x1 = std::max(0, std::min(x1, inW - 1));
            y1 = std::max(0, std::min(y1, inH - 1));
            
            // Sample the four nearest pixels
            IMF::Rgba p00 = inPixels[y0][x0];
            IMF::Rgba p01 = inPixels[y0][x1];
            IMF::Rgba p10 = inPixels[y1][x0];
            IMF::Rgba p11 = inPixels[y1][x1];
            
            // Bilinear interpolation
            float w00 = (1 - wx) * (1 - wy);
            float w01 = wx * (1 - wy);
            float w10 = (1 - wx) * wy;
            float w11 = wx * wy;
            
            IMF::Rgba& p = outPixels[y][x];
            p.r = p00.r * w00 + p01.r * w01 + p10.r * w10 + p11.r * w11;
            p.g = p00.g * w00 + p01.g * w01 + p10.g * w10 + p11.g * w11;
            p.b = p00.b * w00 + p01.b * w01 + p10.b * w10 + p11.b * w11;
            p.a = p00.a * w00 + p01.a * w01 + p10.a * w10 + p11.a * w11;
        }
    }
}

int
main (int argc, char** argv)
{
    const char*       inFile            = 0;
    const char*       outFile           = 0;
    Envmap            type              = ENVMAP_CUBE;
    Envmap            overrideInputType = NUM_ENVMAPTYPES;
    LevelMode         levelMode         = ONE_LEVEL;
    LevelRoundingMode roundingMode      = ROUND_DOWN;
    Compression       compression       = ZIP_COMPRESSION;
    int               mapWidth          = 256;
    int               tileWidth         = 64;
    int               tileHeight        = 64;
    float             padTop            = 0;
    float             padBottom         = 0;
    float             filterRadius      = 1;
    int               numSamples        = 5;
    bool              diffuseBlur       = false;
    bool              verbose           = false;
    EnvmapPixelType   pixelType         = ENVMAP_HALF;

    //
    // Parse the command line.
    //

    if (argc < 2)
    {
        usageMessage (cerr, argv[0], false);
        return -1;
    }

    try
    {
        int i = 1;

        while (i < argc)
        {
            if (!strcmp (argv[i], "-o"))
            {
                //
                // generate a ONE_LEVEL image
                //

                levelMode = ONE_LEVEL;
                i += 1;
            }
            else if (!strcmp (argv[i], "-m"))
            {
                //
                // Generate a MIPMAP_LEVELS image
                //

                levelMode = MIPMAP_LEVELS;
                i += 1;
            }
            else if (!strcmp (argv[i], "-c"))
            {
                //
                // Generate a cube-face map
                //

                type = ENVMAP_CUBE;
                i += 1;
            }
            else if (!strcmp (argv[i], "-l"))
            {
                //
                // Generate a latitude-longitude map
                //

                type = ENVMAP_LATLONG;
                i += 1;
            }
            else if (!strcmp (argv[i], "-ci"))
            {
                //
                // Assume input is a cube-face map
                //

                overrideInputType = ENVMAP_CUBE;
                i += 1;
            }
            else if (!strcmp (argv[i], "-li"))
            {
                //
                // Assume input is a latitude-longitude map
                //

                overrideInputType = ENVMAP_LATLONG;
                i += 1;
            }
            else if (!strcmp (argv[i], "-f32") || !strcmp (argv[i], "--float"))
            {
                //
                // Use 32-bit float pixels
                //

                pixelType = ENVMAP_FLOAT;
                i += 1;
            }
            else if (!strcmp (argv[i], "-w"))
            {
                //
                // Set output image width
                //

                if (i > argc - 2)
                    throw invalid_argument ("Missing width for -w argument");

                mapWidth = strtol (argv[i + 1], 0, 0);

                if (mapWidth <= 0)
                    throw invalid_argument (
                        "Output image width must be greater than zero");

                i += 2;
            }
            else if (!strcmp (argv[i], "-f"))
            {
                //
                // Set filter radius and supersampling rate
                //

                if (i > argc - 3)
                    throw invalid_argument (
                        "Missing filter radius with -f option");

                filterRadius = strtod (argv[i + 1], 0);
                numSamples   = strtol (argv[i + 2], 0, 0);

                if (filterRadius < 0)
                    throw invalid_argument (
                        "Filter radius must not be less than zero");

                if (numSamples <= 0)
                    throw invalid_argument (
                        "Sampling rate must be greater than zero");

                i += 3;
            }
            else if (!strcmp (argv[i], "-b"))
            {
                //
                // Diffuse blur
                //

                diffuseBlur = true;
                i += 1;
            }
            else if (!strcmp (argv[i], "-t"))
            {
                //
                // Set tile size
                //

                if (i > argc - 3)
                    throw invalid_argument ("missing tile size with -t option");

                tileWidth  = strtol (argv[i + 1], 0, 0);
                tileHeight = strtol (argv[i + 2], 0, 0);

                if (tileWidth <= 0 || tileHeight <= 0)
                    throw invalid_argument (
                        "Tile size must be greater than zero");

                i += 3;
            }
            else if (!strcmp (argv[i], "-p"))
            {
                //
                // Set top and bottom padding
                //

                if (i > argc - 3)
                    throw invalid_argument (
                        "missing padding value with -p option");

                padTop    = strtod (argv[i + 1], 0);
                padBottom = strtod (argv[i + 2], 0);

                if (padTop < 0 || padBottom < 0)
                    throw invalid_argument (
                        "Padding must not be less than zero");

                i += 3;
            }
            else if (!strcmp (argv[i], "-d"))
            {
                //
                // Round down
                //

                roundingMode = ROUND_DOWN;
                i += 1;
            }
            else if (!strcmp (argv[i], "-u"))
            {
                //
                // Round down
                //

                roundingMode = ROUND_UP;
                i += 1;
            }
            else if (!strcmp (argv[i], "-z"))
            {
                //
                // Set compression method
                //

                if (i > argc - 2)
                    throw invalid_argument (
                        "Missing compression method with -z option");

                compression = getCompression (argv[i + 1]);
                i += 2;
            }
            else if (!strcmp (argv[i], "-v"))
            {
                //
                // Verbose mode
                //

                verbose = true;
                i += 1;
            }
            else if (!strcmp (argv[i], "-h") || !strcmp (argv[i], "--help"))
            {
                //
                // Print help message
                //

                usageMessage (cout, "exrenvmap", true);
                return 0;
            }
            else if (!strcmp (argv[i], "--version"))
            {
                const char* libraryVersion = getLibraryVersion ();

                cout << "exrenvmap (OpenEXR) " << OPENEXR_VERSION_STRING;
                if (strcmp (libraryVersion, OPENEXR_VERSION_STRING))
                    cout << "(OpenEXR version " << libraryVersion << ")";
                cout << " https://openexr.com" << endl;
                cout << "Copyright (c) Contributors to the OpenEXR Project"
                     << endl;
                cout << "License BSD-3-Clause" << endl;
                return 0;
            }
            else
            {
                //
                // Image file name
                //

                if (inFile == 0)
                    inFile = argv[i];
                else
                    outFile = argv[i];

                i += 1;
            }
        }

        if (inFile == 0 || outFile == 0)
        {
            usageMessage (cerr, argv[0], false);
            return -1;
        }

        //
        // Read the input image.
        //

        EnvmapImage image;
        Header      header;
        RgbaChannels channels;

        readInputImage (
            inFile,
            padTop,
            padBottom,
            overrideInputType,
            verbose,
            image,
            header,
            channels,
            pixelType);

        if (verbose) cout << "converting map format" << endl;

        //
        // If necessary convert the map from latitude-longitude
        // to cube face format, or vice versa.
        //

        EnvmapImage converted;

        if (image.type() == type)
        {
            // Instead of assignment, resize with same parameters and copy pixels
            converted.resize(image.type(), image.dataWindow(), image.pixelType());
            
            // Copy pixels manually
            int w = image.dataWindow().max.x - image.dataWindow().min.x + 1;
            int h = image.dataWindow().max.y - image.dataWindow().min.y + 1;
            
            for (int y = 0; y < h; ++y)
            {
                for (int x = 0; x < w; ++x)
                {
                    converted.pixels()[y][x] = image.pixels()[y][x];
                }
            }
        }
        else if (image.type() == ENVMAP_LATLONG && type == ENVMAP_CUBE)
        {
            IMATH::Box2i dw (
                IMATH::V2i (0, 0), IMATH::V2i (mapWidth - 1, mapWidth * 6 - 1));

            converted.resize (ENVMAP_CUBE, dw, pixelType);

            makeCubeMap (
                image, converted, filterRadius, numSamples, verbose);
            
            if (diffuseBlur)
                blurCubeMap (converted, verbose);
        }
        else // image.type() == ENVMAP_CUBE && type == ENVMAP_LATLONG
        {
            IMATH::Box2i dw (
                IMATH::V2i (0, 0), IMATH::V2i (mapWidth - 1, mapWidth / 2 - 1));

            converted.resize (ENVMAP_LATLONG, dw, pixelType);

            makeLatLongMap (
                image, converted, filterRadius, numSamples, verbose);
            
            if (diffuseBlur)
                blurLatLongMap (converted, verbose);
        }

        //
        // Set up header attributes for the output file
        //

        if (verbose) cout << "writing file " << outFile << endl;

        addEnvmap (header, type);

        header.dataWindow() = converted.dataWindow();
        header.displayWindow() = converted.dataWindow();

        header.compression() = compression;

        if (levelMode != ONE_LEVEL)
            header.setTileDescription(
                TileDescription(
                    tileWidth, tileHeight, levelMode, roundingMode));
        
        // Set channel type based on pixel type
        if (pixelType == ENVMAP_FLOAT)
        {
            // For 32-bit float output, adjust channels
            IMF::ChannelList chanList;
            chanList.insert("R", IMF::Channel(IMF::FLOAT));
            chanList.insert("G", IMF::Channel(IMF::FLOAT));
            chanList.insert("B", IMF::Channel(IMF::FLOAT));
            chanList.insert("A", IMF::Channel(IMF::FLOAT));
            header.channels() = chanList;
        }

        if (strcmp (outFile, inFile) == 0)
        {
            //
            // The input and output files have the same name.
            // Preserve the input file's compression type and
            // line order.
            //

            IMF::RgbaInputFile in (inFile);
            header.compression() = in.compression();
            header.lineOrder() = in.lineOrder();
        }

        //
        // If we are writing a tiled file, the data window must
        // contain the point (0, 0).  Adjust the data window if
        // necessary.
        //

        const IMATH::Box2i& dwi = converted.dataWindow();

        if (levelMode != ONE_LEVEL && (dwi.min.x > 0 || dwi.min.y > 0))
        {
            converted.resize(
                converted.type(), IMATH::Box2i(IMATH::V2i(0, 0), dwi.max - dwi.min), converted.pixelType());
        }

        //
        // Write the output file.
        //

        const char* f = outFile;
        const IMATH::Box2i& dw = converted.dataWindow();
        int w = dw.max.x - dw.min.x + 1;
        int h = dw.max.y - dw.min.y + 1;

        if (type == ENVMAP_CUBE &&
            strchr(outFile, '%') &&
            h == 6 * w &&
            dw.min.x == 0 &&
            dw.min.y == 0 &&
            levelMode == ONE_LEVEL)
        {
            //
            // Special case - we are writing a cube-face map,
            // the output file name contains a '%' character,
            // and the image is not a mipmap or ripmap.
            // Write six separate image files, one for each
            // cube face.
            //

            static const char* faceName[] = {"+X", "-X", "+Y", "-Y", "+Z", "-Z"};

            size_t pos = strchr (outFile, '%') - outFile;
            static const char face[] = {'x', 'x', 'y', 'y', 'z', 'z'};
            static const int  dirs[] = { 0,  1,  2,  3,  4,  5};

            float maxValueFound = 0.0f;
            int extremeValueCount = 0;

            for (int i = 0; i < 6; ++i)
            {
                string name = string(outFile).replace(pos, 1, faceName[i]);

                IMATH::Box2i dw2(IMATH::V2i(0, 0), IMATH::V2i(w - 1, w - 1));
                header.dataWindow() = dw2;
                header.displayWindow() = dw2;
                envmap(header) = ENVMAP_CUBE;
                
                // Create a CubeMapFace enum value based on the direction
                CubeMapFace faceEnum;
                
                switch (i) {
                    case 0: faceEnum = CUBEFACE_POS_X; break;
                    case 1: faceEnum = CUBEFACE_NEG_X; break;
                    case 2: faceEnum = CUBEFACE_POS_Y; break;
                    case 3: faceEnum = CUBEFACE_NEG_Y; break;
                    case 4: faceEnum = CUBEFACE_POS_Z; break;
                    case 5: faceEnum = CUBEFACE_NEG_Z; break;
                    default: throw invalid_argument("Invalid cube face index");
                }
                
                // Use the setEnvmap function from ImfStandardAttributes.h
                envmap(header) = ENVMAP_CUBE;
                
                // Set a custom attribute for the face directly
                StringAttribute faceAttr;
                switch (faceEnum) {
                    case CUBEFACE_POS_X: faceAttr.value() = "+X"; break;
                    case CUBEFACE_NEG_X: faceAttr.value() = "-X"; break;
                    case CUBEFACE_POS_Y: faceAttr.value() = "+Y"; break;
                    case CUBEFACE_NEG_Y: faceAttr.value() = "-Y"; break;
                    case CUBEFACE_POS_Z: faceAttr.value() = "+Z"; break;
                    case CUBEFACE_NEG_Z: faceAttr.value() = "-Z"; break;
                }
                header.insert("envmapFace", faceAttr);

                if (pixelType == ENVMAP_FLOAT) {
                    // Create an OutputFile to directly write float pixels
                    Header faceHeader = header;
                    faceHeader.channels() = IMF::ChannelList();
                    faceHeader.channels().insert("R", IMF::Channel(IMF::FLOAT));
                    faceHeader.channels().insert("G", IMF::Channel(IMF::FLOAT));
                    faceHeader.channels().insert("B", IMF::Channel(IMF::FLOAT));
                    faceHeader.channels().insert("A", IMF::Channel(IMF::FLOAT));
                    
                    IMF::OutputFile outFile(name.c_str(), faceHeader);
                    
                    // Convert Rgba pixels to separate float channels
                    IMF::FrameBuffer frameBuffer;
                    
                    // Allocate temporary buffers for the float data
                    Array2D<float> rBuffer(w, w);
                    Array2D<float> gBuffer(w, w);
                    Array2D<float> bBuffer(w, w);
                    Array2D<float> aBuffer(w, w);
                    
                    // Copy data from Rgba pixels to float buffers
                    const Rgba* pixels = &converted.pixels()[i * w][0];
                    for (int y = 0; y < w; ++y) {
                        for (int x = 0; x < w; ++x) {
                            const Rgba& p = pixels[y * w + x];
                            // Convert to float and check for extreme values
                            float r = convertRgbaValueToFloat(float(p.r), &maxValueFound, &extremeValueCount);
                            float g = convertRgbaValueToFloat(float(p.g), &maxValueFound, &extremeValueCount);
                            float b = convertRgbaValueToFloat(float(p.b), &maxValueFound, &extremeValueCount);
                            float a = float(p.a);
                            
                            // Alpha is handled separately since it's only 0-1 range
                            if (a != a || !std::isfinite(a) || a > 1.0f) a = 1.0f;
                            if (a < 0.0f) a = 0.0f;
                            
                            rBuffer[y][x] = r;
                            gBuffer[y][x] = g;
                            bBuffer[y][x] = b;
                            aBuffer[y][x] = a;
                        }
                    }
                    
                    // Set up the framebuffer
                    frameBuffer.insert("R", Slice(IMF::FLOAT, (char*)&rBuffer[0][0], sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("G", Slice(IMF::FLOAT, (char*)&gBuffer[0][0], sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("B", Slice(IMF::FLOAT, (char*)&bBuffer[0][0], sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("A", Slice(IMF::FLOAT, (char*)&aBuffer[0][0], sizeof(float), w * sizeof(float)));
                    
                    outFile.setFrameBuffer(frameBuffer);
                    outFile.writePixels(w);
                } else {
                    // Use RgbaOutputFile for half-float pixels (standard approach)
                    IMF::RgbaOutputFile out(name.c_str(), header, channels);
                    out.setFrameBuffer(&converted.pixels()[i * w][0], 1, w);
                    out.writePixels(w);
                }
            }

            // After conversion is complete, report any issues found
            reportExtremeValues(extremeValueCount, maxValueFound, verbose);
        }
        else
        {
            //
            // General case - write a single output file that contains
            // all of the environment map image.
            //

            if (levelMode == ONE_LEVEL)
            {
                if (pixelType == ENVMAP_FLOAT) {
                    // Create an OutputFile to directly write float pixels
                    Header outputHeader = header;
                    outputHeader.channels() = IMF::ChannelList();
                    outputHeader.channels().insert("R", IMF::Channel(IMF::FLOAT));
                    outputHeader.channels().insert("G", IMF::Channel(IMF::FLOAT));
                    outputHeader.channels().insert("B", IMF::Channel(IMF::FLOAT));
                    outputHeader.channels().insert("A", IMF::Channel(IMF::FLOAT));
                    
                    IMF::OutputFile out(outFile, outputHeader);
                    
                    // Convert Rgba pixels to separate float channels
                    IMF::FrameBuffer frameBuffer;
                    
                    // Allocate temporary buffers for the float data
                    Array2D<float> rBuffer(w, h);
                    Array2D<float> gBuffer(w, h);
                    Array2D<float> bBuffer(w, h);
                    Array2D<float> aBuffer(w, h);
                    
                    float maxValueFound = 0.0f;
                    int extremeValueCount = 0;

                    for (int y = 0; y < h; ++y) {
                        for (int x = 0; x < w; ++x) {
                            const Rgba& p = converted.pixels()[y][x];
                            // Convert to float and check for extreme values
                            float r = convertRgbaValueToFloat(float(p.r), &maxValueFound, &extremeValueCount);
                            float g = convertRgbaValueToFloat(float(p.g), &maxValueFound, &extremeValueCount);
                            float b = convertRgbaValueToFloat(float(p.b), &maxValueFound, &extremeValueCount);
                            float a = float(p.a);
                            
                            // Alpha is handled separately since it's only 0-1 range
                            if (a != a || !std::isfinite(a) || a > 1.0f) a = 1.0f;
                            if (a < 0.0f) a = 0.0f;
                            
                            rBuffer[y][x] = r;
                            gBuffer[y][x] = g;
                            bBuffer[y][x] = b;
                            aBuffer[y][x] = a;
                        }
                    }
                    
                    // After conversion is complete, report any issues found
                    reportExtremeValues(extremeValueCount, maxValueFound, verbose);
                    
                    // Set up the framebuffer accounting for the data window
                    frameBuffer.insert("R", Slice(IMF::FLOAT, 
                        (char*)&rBuffer[0][0] - dw.min.y * w * sizeof(float) - dw.min.x * sizeof(float),
                        sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("G", Slice(IMF::FLOAT, 
                        (char*)&gBuffer[0][0] - dw.min.y * w * sizeof(float) - dw.min.x * sizeof(float),
                        sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("B", Slice(IMF::FLOAT, 
                        (char*)&bBuffer[0][0] - dw.min.y * w * sizeof(float) - dw.min.x * sizeof(float),
                        sizeof(float), w * sizeof(float)));
                    frameBuffer.insert("A", Slice(IMF::FLOAT, 
                        (char*)&aBuffer[0][0] - dw.min.y * w * sizeof(float) - dw.min.x * sizeof(float),
                        sizeof(float), w * sizeof(float)));
                    
                    out.setFrameBuffer(frameBuffer);
                    out.writePixels(h);
                } else {
                    IMF::RgbaOutputFile out(outFile, header, channels);
                    out.setFrameBuffer(&converted.pixels()[0][0] - dw.min.y * w - dw.min.x, 1, w);
                    out.writePixels(h);
                }
            }
            else
            {
                if (pixelType == ENVMAP_FLOAT) {
                    // Create a tiled OutputFile to directly write float pixels
                    Header tiledHeader = header;
                    tiledHeader.channels() = IMF::ChannelList();
                    tiledHeader.channels().insert("R", IMF::Channel(IMF::FLOAT));
                    tiledHeader.channels().insert("G", IMF::Channel(IMF::FLOAT));
                    tiledHeader.channels().insert("B", IMF::Channel(IMF::FLOAT));
                    tiledHeader.channels().insert("A", IMF::Channel(IMF::FLOAT));
                    
                    // Set up the tiled header
                    tiledHeader.setTileDescription(TileDescription(tileWidth, tileHeight, levelMode, roundingMode));
                    
                    IMF::TiledOutputFile out(outFile, tiledHeader);
                    
                    // Process each level
                    for (int ly = 0; ly < out.numYLevels(); ++ly)
                    {
                        for (int lx = 0; lx < out.numXLevels(); ++lx)
                        {
                            IMATH::Box2i dw2 = out.dataWindowForLevel(lx, ly);
                            int w2 = dw2.max.x - dw2.min.x + 1;
                            int h2 = dw2.max.y - dw2.min.y + 1;

                            EnvmapImage level;
                            level.resize(converted.type(), dw2, pixelType);
                            resampleImage(converted, level, lx + ly);
                            
                            // Allocate temporary buffers for the float data
                            Array2D<float> rBuffer(w2, h2);
                            Array2D<float> gBuffer(w2, h2);
                            Array2D<float> bBuffer(w2, h2);
                            Array2D<float> aBuffer(w2, h2);
                            
                            float maxValueFound = 0.0f;
                            int extremeValueCount = 0;

                            for (int y = 0; y < h2; ++y) {
                                for (int x = 0; x < w2; ++x) {
                                    const Rgba& p = level.pixels()[y][x];
                                    // Convert to float and check for extreme values
                                    float r = convertRgbaValueToFloat(float(p.r), &maxValueFound, &extremeValueCount);
                                    float g = convertRgbaValueToFloat(float(p.g), &maxValueFound, &extremeValueCount);
                                    float b = convertRgbaValueToFloat(float(p.b), &maxValueFound, &extremeValueCount);
                                    float a = float(p.a);
                                    
                                    // Alpha is handled separately since it's only 0-1 range
                                    if (a != a || !std::isfinite(a) || a > 1.0f) a = 1.0f;
                                    if (a < 0.0f) a = 0.0f;
                                    
                                    rBuffer[y][x] = r;
                                    gBuffer[y][x] = g;
                                    bBuffer[y][x] = b;
                                    aBuffer[y][x] = a;
                                }
                            }
                            
                            // After conversion is complete, report any issues found
                            reportExtremeValues(extremeValueCount, maxValueFound, verbose);
                            
                            // Set up the framebuffer accounting for the data window
                            IMF::FrameBuffer frameBuffer;
                            frameBuffer.insert("R", Slice(IMF::FLOAT, 
                                (char*)&rBuffer[0][0] - dw2.min.y * w2 * sizeof(float) - dw2.min.x * sizeof(float),
                                sizeof(float), w2 * sizeof(float), 1, 1, 0.0));
                            frameBuffer.insert("G", Slice(IMF::FLOAT, 
                                (char*)&gBuffer[0][0] - dw2.min.y * w2 * sizeof(float) - dw2.min.x * sizeof(float),
                                sizeof(float), w2 * sizeof(float), 1, 1, 0.0));
                            frameBuffer.insert("B", Slice(IMF::FLOAT, 
                                (char*)&bBuffer[0][0] - dw2.min.y * w2 * sizeof(float) - dw2.min.x * sizeof(float),
                                sizeof(float), w2 * sizeof(float), 1, 1, 0.0));
                            frameBuffer.insert("A", Slice(IMF::FLOAT, 
                                (char*)&aBuffer[0][0] - dw2.min.y * w2 * sizeof(float) - dw2.min.x * sizeof(float),
                                sizeof(float), w2 * sizeof(float), 1, 1, 1.0));
                            
                            out.setFrameBuffer(frameBuffer);
                            out.writeTiles(0, out.numXTiles(lx) - 1, 0, out.numYTiles(ly) - 1, lx, ly);
                        }
                    }
                } else {
                    IMF::TiledRgbaOutputFile out(
                        outFile,
                        header,
                        channels,
                        tileWidth,
                        tileHeight,
                        levelMode,
                        roundingMode);
                    
                    for (int ly = 0; ly < out.numYLevels(); ++ly)
                    {
                        for (int lx = 0; lx < out.numXLevels(); ++lx)
                        {
                            IMATH::Box2i dw2 = out.dataWindowForLevel(lx, ly);
                            int w2 = dw2.max.x - dw2.min.x + 1;
                            int h2 = dw2.max.y - dw2.min.y + 1;

                            EnvmapImage level;

                            level.resize(converted.type(), dw2, pixelType);

                            resampleImage(converted, level, lx + ly);

                            out.setFrameBuffer(&level.pixels()[0][0] - dw2.min.y * w2 - dw2.min.x, 1, w2);
                            out.writeTiles(0, out.numXTiles(lx) - 1, 0, out.numYTiles(ly) - 1, lx, ly);
                        }
                    }
                }
            }
        }
    }
    catch (const exception &e)
    {
        cerr << argv[0] << ": " << e.what() << endl;
        return 1;
    }

    return 0;
}
